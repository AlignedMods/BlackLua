#pragma once

#include "core.hpp"
#include "internal/types.hpp"
#include "internal/compiler/core/string_view.hpp"

#include <vector>
#include <variant>
#include <unordered_map>

namespace BlackLua {
    struct Context;
    using ExternFn = void(*)(Context* ctx);
}

namespace BlackLua::Internal {

    #define TYPED_OP(name) \
        name##I8, \
        name##I16, \
        name##I32, \
        name##I64, \
        name##U8, \
        name##U16, \
        name##U32, \
        name##U64, \
        name##F32, \
        name##F64,

    struct StackSlotIndex {
        StackSlotIndex() = default;
        StackSlotIndex(int32_t slot) : Slot(slot) {}
        StackSlotIndex(int32_t slot, size_t offset, size_t size) : Slot(slot), Offset(offset), Size(size) {}

        StackSlotIndex operator-(int32_t lhs) { return StackSlotIndex(Slot - lhs, Offset, Size); }
        bool operator==(int32_t lhs) { return Slot == lhs; }

        int32_t Slot = 0;
        size_t Offset = 0;
        size_t Size = 0;
    };

    enum class OpCodeType {
        Invalid,
        Nop,

        Push,
        Pop,
        PushStackFrame,
        PopStackFrame,
        Get, // Automaticaly pushes the value onto the stack
        Copy, // Copies a value into another slot
        Dup, // Creates a new stack slot and copies a value into it
        Offset, // Adds a certain offset (specified as a slot) to a specified slot

        LoadI8,
        LoadI16,
        LoadI32,
        LoadI64,
        LoadU8,
        LoadU16,
        LoadU32,
        LoadU64,
        LoadF32,
        LoadF64,
        LoadStr,

        Label,
        Jmp,
        Jt, // Perform a jump if the value at the specified slot is true (value must be a boolean)
        Jf, // Perform a jump if the value at the specified slot is false (value must be a boolean)

        Call, // Performs a jump and sets up a stack frame
        CallExtern, // Calls a native C/C++ function
        Ret, // Performs a jump to the current stack frame's return address, then pops the current stack frame

        TYPED_OP(Negate)

        TYPED_OP(Add)
        TYPED_OP(Sub)
        TYPED_OP(Mul)
        TYPED_OP(Div)
        TYPED_OP(Mod)

        TYPED_OP(Cmp)
        TYPED_OP(Ncmp)
        TYPED_OP(Lt)
        TYPED_OP(Lte)
        TYPED_OP(Gt)
        TYPED_OP(Gte)

// NOTE: These were generated by macros and then inlined
#pragma region Casts

        CastI8ToI8,
        CastI8ToI16,
        CastI8ToI32,
        CastI8ToI64,
        CastI8ToU8,
        CastI8ToU16,
        CastI8ToU32,
        CastI8ToU64,
        CastI8ToF32,
        CastI8ToF64,

        CastI16ToI8,
        CastI16ToI16,
        CastI16ToI32,
        CastI16ToI64,
        CastI16ToU8,
        CastI16ToU16,
        CastI16ToU32,
        CastI16ToU64, 
        CastI16ToF32, 
        CastI16ToF64, 

        CastI32ToI8,
        CastI32ToI16,
        CastI32ToI32,
        CastI32ToI64,
        CastI32ToU8,
        CastI32ToU16,
        CastI32ToU32,
        CastI32ToU64, 
        CastI32ToF32, 
        CastI32ToF64, 

        CastI64ToI8,
        CastI64ToI16,
        CastI64ToI32,
        CastI64ToI64,
        CastI64ToU8,
        CastI64ToU16,
        CastI64ToU32,
        CastI64ToU64,
        CastI64ToF32,
        CastI64ToF64,

        CastU8ToI8,
        CastU8ToI16,
        CastU8ToI32,
        CastU8ToI64,
        CastU8ToU8,
        CastU8ToU16,
        CastU8ToU32,
        CastU8ToU64,
        CastU8ToF32,
        CastU8ToF64,

        CastU16ToI8,
        CastU16ToI16,
        CastU16ToI32,
        CastU16ToI64,
        CastU16ToU8,
        CastU16ToU16,
        CastU16ToU32,
        CastU16ToU64,
        CastU16ToF32,
        CastU16ToF64,

        CastU32ToI8,
        CastU32ToI16,
        CastU32ToI32,
        CastU32ToI64,
        CastU32ToU8,
        CastU32ToU16,
        CastU32ToU32,
        CastU32ToU64,
        CastU32ToF32,
        CastU32ToF64,

        CastU64ToI8,
        CastU64ToI16,
        CastU64ToI32,
        CastU64ToI64,
        CastU64ToU8,
        CastU64ToU16,
        CastU64ToU32,
        CastU64ToU64,
        CastU64ToF32,
        CastU64ToF64,

        CastF32ToI8,
        CastF32ToI16,
        CastF32ToI32,
        CastF32ToI64,
        CastF32ToU8,
        CastF32ToU16,
        CastF32ToU32,
        CastF32ToU64,
        CastF32ToF32,
        CastF32ToF64,

        CastF64ToI8,
        CastF64ToI16,
        CastF64ToI32,
        CastF64ToI64,
        CastF64ToU8,
        CastF64ToU16,
        CastF64ToU32,
        CastF64ToU64,
        CastF64ToF32,
        CastF64ToF64,

#pragma endregion
    };

    #undef TYPED_OP

    struct OpCodeCopy {
        StackSlotIndex DstSlot{};
        StackSlotIndex SrcSlot{};
    };

    struct OpCodeOffset {
        StackSlotIndex Offset{};
        StackSlotIndex Slot{};
        size_t Size = 0;
    };

    struct OpCodeLoad {
        std::variant<i8, u8, i16, u16, i32, u32, i64, u64, f32, f64, Internal::StringView> Data;
    };

    struct OpCodeJump {
        StackSlotIndex Slot{};
        int32_t Label = -1;
    };

    struct OpCodeMath {
        StackSlotIndex LHSSlot{};
        StackSlotIndex RHSSlot{};
    };

    struct OpCode {
        OpCodeType Type = OpCodeType::Invalid;
        std::variant<StackSlotIndex, std::string, OpCodeCopy, OpCodeOffset, OpCodeLoad, OpCodeJump, OpCodeMath> Data;
        std::string DebugData; // Optional debug data the compiler can provide
    };

    struct StackSlot {
        void* Memory = nullptr;
        size_t Size = 0;
        bool ReadOnly = false;
    };

    class VM {
    public:
        explicit VM(Context* ctx);

        // Increments the stack pointer by specified amount of bytes
        // Also creates a new stack slot, which gets set as the current stack slot
        void PushBytes(size_t amount);

        // Pops the current stack slot
        void Pop();

        // Creates a new stack frame
        void PushStackFrame();
        // Removes the current stack frame and goes back to the previous one (if there is one)
        void PopStackFrame();

        void AddExtern(const std::string& signature, ExternFn fn);

        void Call(int32_t label);
        void CallExtern(const std::string& signature);
        
        void StoreBool(StackSlotIndex slot, bool b);
        void StoreChar(StackSlotIndex slot, int8_t c);
        void StoreShort(StackSlotIndex slot, int16_t ch);
        void StoreInt(StackSlotIndex slot, int32_t i);
        void StoreLong(StackSlotIndex slot, int64_t l);
        void StoreFloat(StackSlotIndex slot, float f);
        void StoreDouble(StackSlotIndex slot, double d);
        void StorePointer(StackSlotIndex slot, void* p);

        void SetMemory(StackSlotIndex slot, void* data);
        void* GetMemory(StackSlotIndex slot);

        // Copies the memory at one slot (srcSlot) to another slot (dstSlot)
        void Copy(StackSlotIndex dstSlot, StackSlotIndex srcSlot);

        bool GetBool(StackSlotIndex slot);
        int8_t GetChar(StackSlotIndex slot);
        int16_t GetShort(StackSlotIndex slot);
        int32_t GetInt(StackSlotIndex slot);
        int64_t GetLong(StackSlotIndex slot);
        float GetFloat(StackSlotIndex slot);
        double GetDouble(StackSlotIndex slot);
        void* GetPointer(StackSlotIndex slot);

        // Run an array of op codes in the VM, executing each operations one at a time
        void RunByteCode(const OpCode* data, size_t count);
        void Run();

        // NOTE: The "slot" parameter can be either negative or positive
        // If it's negative, it accesses from the top of stack backwards,
        // AKA: return stack[top of stack + slot]
        // If it's positive though, it accesses from the start of the stack,
        // AKA: return stack[slot]
        StackSlot GetStackSlot(StackSlotIndex slot);
        size_t GetStackSlotIndex(int32_t slot);

        // Sets a breakpoint up for when the program counter hits a specified value
        void AddBreakPoint(int32_t pc);

        void StopExecution();

    private:
        void RegisterLables();
        
    private:
        std::vector<uint8_t> m_Stack;
        size_t m_StackPointer = 0;
        std::vector<StackSlot> m_StackSlots;
        int32_t m_StackSlotPointer = 0;

        struct StackFrame {
            size_t Offset = 0;
            size_t SlotOffset = 0;
            size_t ReturnAddress = SIZE_MAX;
            int32_t ReturnSlot = 0;
        };

        std::vector<StackFrame> m_StackFrames;
        size_t m_CurrentReturnAdress = SIZE_MAX;

        const OpCode* m_Program = nullptr;
        size_t m_ProgramSize = 0;
        size_t m_ProgramCounter = 0;

        std::unordered_map<int32_t, size_t> m_Labels;
        size_t m_LabelCount = 0;

        std::unordered_map<std::string, ExternFn> m_ExternFuncs;

        std::unordered_map<int32_t, bool> m_BreakPoints;

        Context* m_Context = nullptr;
    };

} // namespace BlackLua::Internal
